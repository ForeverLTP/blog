<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一只咸鱼</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://ForeverLTP.github.io/blog/"/>
  <updated>2018-08-15T14:28:39.226Z</updated>
  <id>https://ForeverLTP.github.io/blog/</id>
  
  <author>
    <name>一只咸鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析ConcurrentModificationException异常的原因</title>
    <link href="https://ForeverLTP.github.io/blog/2018/08/15/%E6%B5%85%E6%9E%90ConcurrentModificationException%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>https://ForeverLTP.github.io/blog/2018/08/15/浅析ConcurrentModificationException异常的原因/</id>
    <published>2018-08-15T14:25:58.000Z</published>
    <updated>2018-08-15T14:28:39.226Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;</p><h3>在分析前我们先做几个测试</h3><p></p><pre><code>public class TestList {    public static void main(String[]args){      List&lt;String&gt; list = new ArrayList&lt;String&gt;();      list.add(&quot;1&quot;);list.add(&quot;2&quot;);      list.add(&quot;3&quot;);list.add(&quot;4&quot;);        TestList.testFor(list);      TestList.testForeach(list);      TestList.testIteratorForListRemove(list);      TestList.testIteratorForIteratorRemove(list);   }   //测试For循环   public static void testFor(List&lt;String&gt; list){      try{        for(int i=0;i&lt;list.size();i++){            System.out.println(&quot;长度：&quot;+list.size());            if(list.contains(&quot;1&quot;)){                list.remove(i);            }            System.out.println(&quot;长度：&quot;+list.size());            System.out.println(&quot;-----------------------------&quot;);        }      }catch(ConcurrentModificationException e){        System.out.println(&quot;出现ConcurrentModificationException异常&quot;);      } } //测试Foreach循环 public static void testForeach(List&lt;String&gt; list){    try{        for(String str:list){            System.out.println(&quot;长度：&quot;+list.size());            if(list.contains(&quot;1&quot;)){                list.remove(str);            }            System.out.println(&quot;长度：&quot;+list.size());            System.out.println(&quot;-----------------------------&quot;);        }    }catch(ConcurrentModificationException e){        System.out.println(&quot;出现ConcurrentModificationException异常&quot;);    } } //测试迭代器使用List的remove方法 public static void testIteratorForListRemove(List&lt;String&gt; list){    try{        Iterator&lt;String&gt;  it = list.iterator();        while(it.hasNext()){            System.out.println(&quot;长度：&quot;+list.size());            String str = it.next();            if(list.contains(&quot;1&quot;)){                list.remove(str);            }            System.out.println(&quot;长度：&quot;+list.size());            System.out.println(&quot;-----------------------------&quot;);        }    }catch(ConcurrentModificationException e){        System.out.println(&quot;出现ConcurrentModificationException异常&quot;);    } } //测试迭代器使用迭代器的remove方法 public static void testIteratorForIteratorRemove(List&lt;String&gt; list){    try{        Iterator&lt;String&gt;  it = list.iterator();        while(it.hasNext()){            System.out.println(&quot;长度：&quot;+list.size());            String str = it.next();            if(list.contains(&quot;1&quot;)){                it.remove();            }            System.out.println(&quot;长度：&quot;+list.size());            System.out.println(&quot;-----------------------------&quot;);        }    }catch(ConcurrentModificationException e){        System.out.println(&quot;出现ConcurrentModificationException异常&quot;);    } }}</code></pre><h3>结果展示</h3><pre><code>//For循环长度：4长度：3-----------------------------长度：3长度：3-----------------------------长度：3长度：3-----------------------------//Foreach循环（捕获异常）长度：4长度：3-----------------------------出现ConcurrentModificationException异常//迭代器List的remove（捕获异常）长度：4长度：3-----------------------------长度：3出现ConcurrentModificationException异常//迭代器的remove长度：4长度：3-----------------------------长度：3长度：3-----------------------------长度：3长度：3-----------------------------长度：3长度：3-----------------------------</code></pre><h3>&nbsp;&nbsp;通过结果显示我们能很清楚的知道使用<font color="red">Foreach</font>和<font color="red">使用迭代器且使用List自身的remove方法</font>会抛出ConcurrentModificationException异常。</h3><br><h3>&nbsp;&nbsp;那么为什么会是这样的结果呢？首先先分析这四个遍历的情况，第一个For循环是最基础的循环，其他三个都是使用了迭代器进行循环，而抛出的异常的都是使用了迭代器的循环，由此我们可以推断产生异常的原因和迭代器内部机制有很大的关系，这就好办了，现在我们来看看Iterator迭代器中的源码情况，在这里注意一下expectedModCount、modCount这两个变量，抛出异常就是它们两个不相等，下面详细讲解为什么会不相等。</h3><pre><code>//源码private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    Itr() {}    public boolean hasNext() {        return cursor != size;    }    @SuppressWarnings(&quot;unchecked&quot;)    public E next() {        checkForComodification();        int i = cursor;        if (i &gt;= size)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i + 1;        return (E) elementData[lastRet = i];    }    public void remove() {        if (lastRet &lt; 0)            throw new IllegalStateException();        checkForComodification();        try {            ArrayList.this.remove(lastRet);            cursor = lastRet;            lastRet = -1;            expectedModCount = modCount;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }    @Override    @SuppressWarnings(&quot;unchecked&quot;)    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {        Objects.requireNonNull(consumer);        final int size = ArrayList.this.size;        int i = cursor;        if (i &gt;= size) {            return;        }        final Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length) {            throw new ConcurrentModificationException();        }        while (i != size &amp;&amp; modCount == expectedModCount) {            consumer.accept((E) elementData[i++]);        }        // update once at end of iteration to reduce heap write traffic        cursor = i;        lastRet = i - 1;        checkForComodification();    }    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><h3>&nbsp;&nbsp;通过上面的测试示例我们可以很清楚的知道会用到源码中的<font color="red">hashNext、next、remove等</font>方法，先分析Foreach循环，Foreach循环的原理是默认会调用迭代器中的hashNext和next方法，首先先用hashNext方法判断是否还有下一个元素，如果有，就调用next方法，获取这个元素并赋值给冒号前面的变量，如此重复直至hashNext为fasle的时候就会结束循环。因此Foreach循环会调用迭代器中的两个方法hashNext和next，hashNext方法我们看源码没有什么毛病，重点是在next方法。</h3><pre><code>public E next() {        checkForComodification();        int i = cursor;        if (i &gt;= size)            throw new NoSuchElementException();        Object[] elementData = ArrayList.this.elementData;        if (i &gt;= elementData.length)            throw new ConcurrentModificationException();        cursor = i + 1;        return (E) elementData[lastRet = i];}final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();}</code></pre><h3>&nbsp;&nbsp;首先看第一行它会调用checkForComodification方法进行检查modCount和expectedModCount是否相等，不相等就会抛出异常。这时候你会有疑问了（在源码中它们是相等的啊）？</h3><pre><code>int expectedModCount = modCount;</code></pre><h3>没错在迭代器中它们是相等的，但是你调用了list.remove(index)方法，注意看下面代码remove方法的第二行，modCount++;自增了，当list调用了remove方法后Foreach循环会调用迭代器中的next方法，next方法会调用checkForComodification方法进行判断所以就会抛出ConcurrentModificationException异常。</h3>  <pre><code> //ArrayList中的remove方法 public E remove(int index) {    rangeCheck(index);    modCount++;    E oldValue = elementData(index);    int numMoved = size - index - 1;    if (numMoved &gt; 0)        System.arraycopy(elementData, index+1, elementData, index,                         numMoved);    elementData[--size] = null; // clear to let GC do its work    return oldValue;}</code></pre><h3>那么为什么第四个方法也就是使用了迭代器本身的remove方法不会报错呢？且看源码</h3><pre><code>public void remove() {        if (lastRet &lt; 0)            throw new IllegalStateException();        checkForComodification();        try {            ArrayList.this.remove(lastRet);            cursor = lastRet;            lastRet = -1;            expectedModCount = modCount;        } catch (IndexOutOfBoundsException ex) {            throw new ConcurrentModificationException();        }    }</code></pre><h3>迭代器中的已经对这两个变量做了处理让它们始终是相等的。</h3><br><h2>总结</h2><br><h3>&nbsp;&nbsp;1、尽量不要在遍历的时候修改集合中的元素</h3><br><h3>&nbsp;&nbsp;2、如果硬要修改就使用迭代器本身自带的修改元素的方法</h3><br><h3>&nbsp;&nbsp;3、哈哈，选择for循环是最稳的</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;nbsp;&amp;nbsp;&lt;/p&gt;&lt;h3&gt;在分析前我们先做几个测试&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TestList {

    public static void main(String[]args){
      List&amp;lt
      
    
    </summary>
    
      <category term="BUG" scheme="https://ForeverLTP.github.io/blog/categories/BUG/"/>
    
    
      <category term="异常" scheme="https://ForeverLTP.github.io/blog/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="迭代器" scheme="https://ForeverLTP.github.io/blog/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
      <category term="ConcurrentModificationException" scheme="https://ForeverLTP.github.io/blog/tags/ConcurrentModificationException/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github快速高效搭建一个自定义页面作为首页的博客</title>
    <link href="https://ForeverLTP.github.io/blog/2018/08/14/hexo-github%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E4%BD%9C%E4%B8%BA%E9%A6%96%E9%A1%B5%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://ForeverLTP.github.io/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/</id>
    <published>2018-08-14T14:25:59.000Z</published>
    <updated>2018-08-15T14:28:43.976Z</updated>
    
    <content type="html"><![CDATA[<p></p><h2>前言</h2> <p></p><h3>&nbsp;&nbsp;先从标题来说，为什么说是快速高效呢？因为我已经把大部分坑都踩过了，是不是很贴心，哈哈，在会出现错误的地方我会给予相应的提示和出错解决方法，这样可以减少不必要的解决bug的时间，废话少说，下面开始吧。 </h3><br><h2>准备工作</h2><br><h3>1、构建git环境 </h3><br><h3>&nbsp;&nbsp;构建git环境是指本地安装git软件以及与远程github相连，如果这一步已经完成了的可以进入下一步，如果未完成的请点击<a href="https://blog.csdn.net/sihai12345/article/details/72379831" target="_blank" rel="noopener">这里</a><br><h3>2、安装node.js</h3><br><h3>&nbsp;&nbsp;安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>(傻瓜式安装一键到底)<br><h3>3、搭建hexo环境 （<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">官方教程请点击这里</a> ） </h3><br><h3>&nbsp;&nbsp;1、使用第一步安装好的Git Bash工具，输入：</h3><pre><code>npm install -g hexo-cli </code></pre><h3>安装hexo，如图</h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/1.jpg" alt=""><br><h3>&nbsp;&nbsp;<font color="red">注：</font>如果产生错误提示：</h3><pre><code>npm command not found</code></pre><h3>，则说明一种可能是你第二步安装Node.js的配置未生效，可以先到本地电脑属性 &rarr; 高级系统设置&rarr;环境变量&rarr;path中查看是否有Node.js软件的安装路径（eg: C:\Program Files\nodejs），如果忘记安装的位置就重启一下电脑系统自动会配置。 </h3><br><h3>&nbsp;&nbsp;2、hexo init 地址，初始化一个工作空间，地址随便填写也可以不写，不写就是在当前目录下创建（建议创建一个目录），尽量短些，因为后续很多操作是需要在这个工作空间执行的，避免切换目录输入的麻烦。  </h3><br><h3>&nbsp;&nbsp;3、输入命令 cd 地址，切换到刚才你初始化的工作空间  </h3><br><h3>&nbsp;&nbsp;4、安装npm，输入命令 ：</h3><pre><code>npm install     </code></pre><h3>&nbsp;&nbsp;<font color="red">注：</font>常见错误：  </h3><br><h3>&emsp;&emsp;&emsp;1、部署的时候提示找不到git  </h3><br><h3>&emsp;&emsp;&emsp;解决方法： </h3><pre><code>npm install hexo-deployer-git --save  </code></pre><h3>&emsp;&emsp;&emsp;2、执行hexo server提示找不到该指令  </h3><br><h3>&emsp;&emsp;&emsp;解决方法： </h3><pre><code>npm install hexo-server --save    </code></pre><p></p><h2>快速开始 </h2> <p></p><h3>&emsp;&emsp;首先先理清楚自己的需求，我们需要的是做一个具有自定义页面作为首页的博客，因此需要在github中创建两个仓库，一个仓库是放自定义页面，另一个是放博客主页的。</h3><br><h3>&emsp;&emsp;先别着急一个一个来，首先先创建一个放自定义页面的仓库。 </h3><br><h3>1、进入github中点击New repository，名字为：xx.github.io,其中xx要与Owner一致。</h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/2.jpg" alt=""><br><h3>2、点击Settings并在GitHub Pages中点击Choose a theme，进入后随便选择一个主题，没关系因为之后都是要被替换成你自己的自定义页面。</h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/4.jpg" alt=""><br><h3>&emsp;&emsp;完成以上操作的时候，你的仓库中就会是这样的效果。</h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/5.jpg" alt=""><br><h3>&emsp;&emsp;之后就需要你自己设计一个页面然后将仓库的文件替换，我的仓库的效果图如下。</h3>  <img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/6.jpg" alt=""><br><h3><font color="red">注：</font><font color="blue">git操作：先进入你初始化的git工作空间，（如果忘记了在哪里了，可以重新初始化一个，输入命令：git init 地址）</font></h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/7.jpg" alt=""><br><br><h3>使用命令可以查看一下工作空间存在的文件信息：</h3><pre><code>ls -a</code></pre><h3>输入命令可以查看当前有哪些远程库以及与那个github仓库连接：</h3><pre><code>git remote -v</code></pre><h3>创建一个远程库以及与github仓库连接：</h3><pre><code>git remote add origin ssh（origin是指起的远程仓库名称可以随便起，ssh指的是你仓库的地址详情如下图）</code></pre><h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/8.jpg" alt="">完成后可以将你需要上传的文件添加到暂存区中：</h3><pre><code>git add xx</code></pre><h3>添加完成后使用命令：</h3><pre><code>git status   //查看是否添加成功，绿色标识已经添加到暂存区了</code></pre><h3>使用命令：</h3><pre><code>git commit -m &quot;第一次提交&quot;   //提交到本地库中</code></pre><h3>最后在使用: </h3><pre><code>git push origin master    //推送到github远程仓库中&lt;/font&gt;  </code></pre><h3>&emsp;&emsp;如果以上步骤都成功了，那么现在可以开始创建第二个仓库也就是作为博客主体使用的，同样在github中新建一个仓库，这里的仓库名称是可以随便取，例如我取的名称是：blog,然后选一个主题，现在在github上的操作就已经完成了，那么现在回到本地进入hexo工作环境中，如下图</h3><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/9.jpg" alt="">。<br><h3>，打开_congfig.yml文件，搜索关键字：url，对url和root进行配置<font color="red">（千万注意yml文件的格式很规范，不准使用tab键，冒号后面空1格，缩进是空2格，千万记住设置错误找都找不到出错在哪里）</font>，例如： </h3> <pre><code>url: https://主页的名称/主体博客的名称  root: /主体博客的名称/  </code></pre><p><img src="/blog/2018/08/14/hexo-github快速高效搭建一个自定义页面作为首页的博客/10.jpg" alt="">  </p><h3>此时已经完成前半部分配置，接下来搜索：deploy关键字，将hexo部署到哪里去，例如：</h3> <pre><code>deploy:    type: git    //部署方式    repository: https://github.com/ForeverLTP/log.git    //repository是指你主体博客仓库的地址    branch: master  //提交到master分支上  </code></pre><h3>以上配置完成，现在可以将hexo部署到github中，使用命令：</h3><br>    hexo c   //等待完成后<br>    hexo g   //等待完成<br>    hexo d<br><h3>这样基础的具有自定义页面的基础博客就完成了。</h3></h3></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;/p&gt;&lt;h2&gt;前言&lt;/h2&gt; &lt;p&gt;&lt;/p&gt;
&lt;h3&gt;&amp;nbsp;&amp;nbsp;先从标题来说，为什么说是快速高效呢？因为我已经把大部分坑都踩过了，是不是很贴心，哈哈，在会出现错误的地方我会给予相应的提示和出错解决方法，这样可以减少不必要的解决bug的时间，废话少说，下面开始
      
    
    </summary>
    
      <category term="教程" scheme="https://ForeverLTP.github.io/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="https://ForeverLTP.github.io/blog/tags/hexo/"/>
    
      <category term="github" scheme="https://ForeverLTP.github.io/blog/tags/github/"/>
    
      <category term="自定义" scheme="https://ForeverLTP.github.io/blog/tags/%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    
      <category term="博客" scheme="https://ForeverLTP.github.io/blog/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>源起</title>
    <link href="https://ForeverLTP.github.io/blog/2018/08/13/%E6%BA%90%E8%B5%B7/"/>
    <id>https://ForeverLTP.github.io/blog/2018/08/13/源起/</id>
    <published>2018-08-13T14:39:09.000Z</published>
    <updated>2018-08-13T15:02:21.630Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;算算已经工作了半年了，经常会有一些问题需要去思考，有时候我知道它的意思，但是就是表达不出来，总感觉缺少些什么，这种朦胧懵懂的感觉很不好（这也是我不太会说的一个原因），所以我就想记录，在记录或者说整合的时候你会遇到其他各种各样的问题，这或许就是我缺少的那部分东西，所以我想要去探寻我那部分缺失的东西。<br>&emsp;&emsp;哈哈，想拥有一个自己的博客很久，但是老是觉得自己技术不太行、没什么可写的而放弃。现在想开了，作为一个年轻人就是要敢于做，至少不会后悔，就像我首页说的那样JUST DO IT,做就完事了。<br>&emsp;&emsp;搭建这个博客和首页样式的制作花费了我二天的时间，虽然网上有教程，但是当你自己去做的时候你会发现其实并不想教程中说的那么简单，即使完全按照他们的步骤来，因为种种原因，也会出错，也会有问题，这时候就要你自己来解决或百度解决，也许当时你会烦恼，但是当你都解决了的时候你会很高兴，那种无法形容的高兴，这就是问题它的魅力所在，同样也是我想要的感觉。<br>&emsp;&emsp;说了这么多废话，总而言之，今天我的博客诞生了。最后，借我老师的一句话结尾，坐在台下你永远无法体会站在台上的压力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;算算已经工作了半年了，经常会有一些问题需要去思考，有时候我知道它的意思，但是就是表达不出来，总感觉缺少些什么，这种朦胧懵懂的感觉很不好（这也是我不太会说的一个原因），所以我就想记录，在记录或者说整合的时候你会遇到其他各种各样的问题，这或许就是我缺少的
      
    
    </summary>
    
    
  </entry>
  
</feed>
