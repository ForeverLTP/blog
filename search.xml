<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Springboot整合thymeleaf实现国际化]]></title>
    <url>%2Fblog%2F2019%2F01%2F14%2FSpringboot%E6%95%B4%E5%90%88thymeleaf%E5%AE%9E%E7%8E%B0%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 知识概念 一、什么是Thymeleaf？ Thymeleaf是适用于web和独立环境的现代服务器端java模板引擎Thymeleaf的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。借助Spring Framework的模块，与您喜欢的工具的大量集成，以及插入您自己的功能的能力，Thymeleaf是现代HTML5 JVM Web开发的理想选择 - 尽管它可以做得更多。总之是为了在html动态能显示数据。二、Html和Jsp的区别• Html：超文本标记语言，静态页面，可以直接被浏览器渲染成页面。html完美体现前后端模块分离，各司其职的属性，同时还减轻了服务器端的压力，但是会增加浏览器即客户端的压力。• Jsp：全称为java server page，需要服务器动态拼接页面后传递给浏览器，然后浏览器再渲染成页面。它是需要服务器进行一系列操作因此会增加服务器端的压力。三、知识梳理 &nbsp;&nbsp;&nbsp;&nbsp;如上图可知springboot框架默认的Local解析器为AcceptHeaderLocaleResolver，AcceptHeaderLocaleResolver又是根据Request Headers的accept-language的值来解析Local，并且是不可变的。那么想要实现国际化，就要使用SessionLocaleResolver或者CookieLocaleResolver。 四、示例 框架：Springboot;&nbsp;&nbsp;(thymeleaf官方使用教程) application.properties spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.mode=HTML spring.thymeleaf.encoding=UTF-8 spring.thymeleaf.content-type=text/html spring.thymeleaf.cache=false spring.resources.chain.strategy.content.enabled=true spring.resources.chain.strategy.content.paths=/** Pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; I18nConfig @Configuration public class I18nConfig { //定义资源位置及编码方式 @Bean public ResourceBundleMessageSource messageSource(){ ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(&quot;static/i18n/message&quot;); messageSource.setDefaultEncoding(&quot;UTF-8&quot;); messageSource.setCacheSeconds(1); return messageSource; } //定义Local解析方式并设置默认为中文 @Bean public LocaleResolver localeResolver(){ SessionLocaleResolver resolver = new SessionLocaleResolver(); resolver.setDefaultLocale(Locale.CHINA); return resolver; } } 资源文件位置如下图： 国际化切换 @RestController @RequestMapping(value=&quot;/i18n&quot;) public class InternationalController { @RequestMapping(value=&quot;/selectLanguage&quot;) public String selectLanguage(String language,HttpServletRequest request){ Locale locale = null; if(language.equals(&quot;ENGLISH&quot;)){ locale = new Locale(&quot;en&quot;, &quot;US&quot;); request.getSession().setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, locale); request.getSession().setAttribute(&quot;lan&quot;, &quot;en_US&quot;); }else{ locale = new Locale(&quot;zh&quot;, &quot;CN&quot;); request.getSession().setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, locale); request.getSession().setAttribute(&quot;lan&quot;, &quot;zh_CN&quot;); } return &quot;true&quot;; } } 三、总结 Springboot结合Thymeleaf实现国际化原理就是根据用户的需求动态的切换不同资源文件。与代码来说就是更换不同的Locale，不同的Locale，就从不同的资源文件中获取数据]]></content>
      <categories>
        <category>Springboot整合</category>
      </categories>
      <tags>
        <tag>thymeleaf</tag>
        <tag>国际化</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LuceneDemo]]></title>
    <url>%2Fblog%2F2019%2F01%2F14%2FLuceneDemo%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 知识概念 一、什么是Lucene？Lucene是apache软件基金会jakarta项目组的一个顶级子项目，因为它不是一个完整的搜索引擎，而是一个具有全文检索引擎的架构，提供了完整的查询方法、索引引擎和部分文本分析的引擎，所以它是一个全文搜索引擎的工具包。Lucene的目的是提供一个简单、易用的便于开发的工具包，以方便开发人员实现全文检索的功能，或者是以其为基础建立一个完整的全文检索系统。作为apache的一个开源项目，Lucene自从问世之后，就深受广大用户群体的喜爱，程序员们不仅可以使用它来构建具体的全文检索应用，而且还可以将它与各种系统软件相结合，以及用其搭建Web应用，甚至某些商业软件也采用了Lucene作为其全文搜索的核心二、Lucene的优势（1）索引文件格式像java语言一样可以独立于各个平台。因为Lucene规定了一套以8位字节为基础的索引文件格式，使得不同平台的应用都能够使用索引文件。（2）在传统全文检索引擎的倒排索引的基础上，实现了分块索引，即可以对新的数据创建新的小索引文件，提升检索速度。最后通过和已有的索引库文件合并，从而达到优化的目的。（3）Lucene可以扩展已有的关键词库，即可以通过需求将所需词组扩展到Lucene中 （4）设计了独立于语言和文件格式的文本分析接口，索引器通过接受Token流完成索引文件的创立，用户扩展新的语言和文件格式，只需要实现文本分析的接口。（5）Lucene底层已经实现了大部分的检索功能，已经可以满足需求，用户只需要调用方法即可获得强大的搜索能力，Lucene的检索默认实现了一些操作如布尔操作、模糊查询（Fuzzy Search）、分组查询等等三、知识梳理 使用Lucene开发应用，首先必须先理解几个重要的概念，分别是analyzer、field、document、term、tocken。 （1） analyzer中文意思是分词，它的作用是将域中的文字按照某种规则切割成若干个关键字,后期检索就是通过匹配关键字来进行的。 Lucene自带了几个分词器，这些都对中文分词不是很理想，所以就需要扩展其他的分词器如IK分词器。（2） field指的是域， Lucene按照你的需求进行区域划分，将分词后的数据放入相应的域中，它的作用是用户可以通过指定某个域来进行范围查询。域有两个属性：储存和索引。通过对储存属性的设定可以为该域是否储存即此域的数据是否可以显示；对索引属性的设置可以规定该域的数据是否分词。（3） document表示的是文档，文档可以包含一个域也可以包含多个域，每个文档的域可以相同也可以不同。数据源中的每一行记录表示就是一个文档。可以通过关键字匹配查询到相应的文档id，通过文档id可以获得文档中的域的信息从而达到检索的目的。（4） term指的是检索的最小单元即分词后的关键字，term由两部分组成：关键字文本和这个关键字所在的域。（5） tocken表示的是term的一次出现，它包含term文本和相应的起止偏移，以及一个类型字符串。一句话中可以出现多次相同的词语，它们都用同一个term表示，但是用不同的tocken，每个tocken标记该词语出现的地方。使用Lucene开发应用的流程如下图。它的流程分为两部分：第一部分是建立索引库，即先是需要获取数据，然后将数据划分到指定域中，对域中的数据进行分词，并将每条记录添加到文档中，最后通过这些文档组成了索引库。第二部分是用户使用的时候产生，用户编写好查询条件，lucene分析查询条件然后到索引库中去检索，最后将数据结果展示给用户。四、示例框架：Springboot;&nbsp;&nbsp;(易白教程) Pom.xml &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;7.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;7.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;7.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt; &lt;version&gt;7.3.1&lt;/version&gt; &lt;/dependency&gt; IndexUtils public class IndexUtils { private static Logger logger = Logger.getLogger(IndexUtils.class); List&lt;Document&gt; doList = null; Document document = null; IndexSearcher searcher = null; IndexWriter writer = null; IndexReader reader = null; IndexWriter ramWriter = null; public static Analyzer analyzer; static Directory fsd; static Path path; // 静态资源加载，当类加载的时候运行(因为只要加载一次) static { logger.info(&quot;lucene初始化&quot;); try { // IKAnalyzer中文分词器（可扩展） // 标准分词器：Analyzer analyzer = new StandardAnalyzer(); // new IKAnalyzer(true)表示智能分词 // new IKAnalyzer(false)表示最细粒度分词(默认也是这个) analyzer = new StandardAnalyzer(); path = Paths.get(&quot;mysql/keyword&quot;);// 磁盘索引库路径(相对路径) fsd = FSDirectory.open(path);// 创建磁盘目录 } catch (IOException e) { logger.error(&quot;lucene初始化发生IOException异常&quot;); e.printStackTrace(); } } /** * 采集数据 * * @throws IOException */ public void creatIndex() throws IOException { // 分词 doList = analyze(); // lucene没有提供相应的更新方法，只能先删除然后在创建新的索引(耗时) // 由于IndexWriter对象只能实例化一次如果使用内存和磁盘想结合的方式则需要两个IndexWriter故行不通 // 虽然创建的时候耗时但是这样使得文件只有6个 ，搜索时减少了一些io操作加快了搜索速度 writer = deleteAllIndex(); for (Document doc : doList) { writer.addDocument(doc); } writer.commit(); writer.close(); } /** * 分词，工具方法 * * @throws IOException */ public List&lt;Document&gt; analyze() throws IOException { doList = new ArrayList&lt;Document&gt;(); File resource = new ClassPathResource(&quot;mysql.txt&quot;).getFile(); BufferedReader reader = new BufferedReader(new FileReader(resource)); String keyword = null; while( (keyword=reader.readLine()) != null){ document = new Document(); Field mysql = new TextField(&quot;keyword&quot;, keyword, Store.YES); document.add(mysql); doList.add(document); } if(reader != null){ reader.close(); } return doList; } /** * 删除索引库 * * @throws IOException */ public IndexWriter deleteAllIndex() throws IOException { writer = getWriter(); writer.deleteAll(); return writer; } /** * 获取搜索器 * * @param reader * @return * @throws IOException */ public IndexSearcher getIndexSearcher() throws IOException { if (null == searcher) { reader = DirectoryReader.open(fsd); searcher = new IndexSearcher(reader); } return searcher; } /** * 获取磁盘写入 * * @return * @throws IOException */ public IndexWriter getWriter() throws IOException { if (null == writer) { // 为什么使用这种new匿名方式创建该对象 IndexWriterConfig(Version.LUCENE_4_10_3, // analyzer) // 因为IndexWriterConfig对象只能使用一次、一次、一次 writer = new IndexWriter(fsd, new IndexWriterConfig(analyzer)); } return writer; } /** * 工具方法 * * @param query * @param num * @return List&lt;Document&gt; * @throws IOException */ public static List&lt;Document&gt; searchUtil(Query query, IndexSearcher searcher) throws IOException { List&lt;Document&gt; docList = new ArrayList&lt;Document&gt;(); TopDocs topDoc = searcher.search(query, Integer.MAX_VALUE); ScoreDoc[] sd = topDoc.scoreDocs; for (ScoreDoc score : sd) { int documentId = score.doc; Document doc = searcher.doc(documentId); docList.add(doc); } return docList; } /** * 给查询的文字上色 * * @param query * 查询方法 * @param analyzer * 分词器 * @param fieldName * 域名 * @param fieldContent * 查询内容 * @param fragmentSize * 文字结果截取的长度 * @return * @throws IOException * @throws InvalidTokenOffsetsException */ public static String displayHtmlHighlight(Query query, Analyzer analyzer, String fieldName, String fieldContent, int fragmentSize) throws IOException, InvalidTokenOffsetsException { // 创建一个高亮器 Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(&quot;&lt;font style=&apos;font-weight:bold;&apos;&gt;&quot;, &quot;&lt;/font&gt;&quot;), new QueryScorer(query)); Fragmenter fragmenter = new SimpleFragmenter(fragmentSize); highlighter.setTextFragmenter(fragmenter); return highlighter.getBestFragment(analyzer, fieldName, fieldContent); } } 初始化索引库需要调用creatIndex方法 SearchMethod public class SearchMethod extends IndexUtils{ List&lt;Document&gt; docList = null; /** * 通过lucene最小单元term进行查询 * @return * @throws IOException */ public List&lt;Document&gt; searchByTermQuery(Term term) throws IOException{ searcher = getIndexSearcher(); Query query = new TermQuery(term); docList = searchUtil(query,searcher); return docList; } /** * 前缀查询 * @param term * @return * @throws IOException */ public Map&lt;List&lt;Document&gt;,Query&gt; searchByPrefixQuery(Term term) throws IOException{ Map&lt;List&lt;Document&gt;,Query&gt; map = new HashMap&lt;List&lt;Document&gt;,Query&gt;(); searcher = getIndexSearcher(); Query query = new PrefixQuery(term); docList = searchUtil(query,searcher); map.put(docList, query); return map; } /** * 智能提示 * @param pageIndex * @param pageSize * @param field * @param content * @return * @throws ParseException * @throws IOException */ public List&lt;String&gt; suggestion(String field,String content) throws ParseException, IOException{ List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); QueryParser qp = new QueryParser(field, analyzer); Query query = qp.parse(content); searcher = getIndexSearcher(); TopDocs topDoc = searcher.search(query, Integer.MAX_VALUE); ScoreDoc[] sd = topDoc.scoreDocs; for (ScoreDoc score : sd) { int documentId = score.doc; Document doc = searcher.doc(documentId); String str = doc.get(field); strList.add(str); } return strList; } /** * QueryParser 会对输入的语句进行分词然后查询 * @return * @throws ParseException * @throws IOException */ public Map&lt;List&lt;Document&gt;,Query&gt; searchByQueryParser(String field,String content) throws ParseException, IOException{ Map&lt;List&lt;Document&gt;,Query&gt; map = new HashMap&lt;List&lt;Document&gt;,Query&gt;(); QueryParser qp = new QueryParser(field, analyzer); Query query = qp.parse(content); searcher = getIndexSearcher(); map.put(searchUtil(query,searcher), query); return map; } /** * 多域、多条件查询 * @param fields 域数组 * @param queries 查询数组 * @param flags 域之间的关系 * @return * @throws ParseException * @throws IOException */ public List&lt;Document&gt; searcherByMultiFieldQueryParser(String[] fields,String[] queries,Occur[] flags) throws ParseException, IOException{ Query mfQuery = MultiFieldQueryParser.parse(queries, fields, flags, analyzer); searcher = getIndexSearcher(); docList = searchUtil(mfQuery,searcher); return docList; } } 获取Document后可以通过调用它的get(域名)方法获取查询记录在该域的内容三、总结lucene是一个健全的工具包，我们可以通过它来构建一个完整的检索系统。]]></content>
      <categories>
        <category>lucene</category>
      </categories>
      <tags>
        <tag>Lucene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket详解]]></title>
    <url>%2Fblog%2F2019%2F01%2F11%2Fwebsocket%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 前言 &nbsp;&nbsp;&nbsp;&nbsp;传统的web项目都是客户端发送请求，服务器响应这种单工模式，但是如果需要服务器端主动发送数据就做不到，于是就有了Websocket。 知识概念 一、什么是Websocket？ WebSocket是一种在单个TCP连接上进行全双工通信的协议二、Websocket协议和Http协议• Http协议：Http协议是个无连接协议，Http1.0不支持持久连接即一次连接只能处理一个请求，为了弥补这一缺陷就有了Http1.1，Http1.1支持持久连接即一次连接可以处理多个请求，但一个request只能对应一个response，同时Http协议也是一个无状态协议即对于事务处理没有记忆能力，因此需要借助外部机制如Session或Cookie来实现记忆。Http协议建立tcp/ip连接需要进行3次握手，断开连接需要进行4次挥手，同时它只支持单工模式一个request，一个response，response很被动。• Websocket协议：Websocket协议是基于Http协议，建立连接只需要一次握手即可，本身支持持久连接，是一个全双工的通信协议。三、Websocket能做什么？Websocket最主要的功能是实现了全双工通信即客户端和服务器都可以充当主动方进行发送数据。四、示例框架：Springboot;&nbsp;&nbsp;(菜鸟教程)Pom.xml &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 服务器端WebSocketConfig @Configuration public class WebSocketConfig { //检测带有@ServerEndpoint的Bean并注册它们，交给Spring容器进行管理 @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } WebSocketServer @Component @ServerEndpoint(value=&quot;/websocket&quot;) public class WebSocketServer { private static Logger logger = Logger.getLogger(WebSocketServer.class); public static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketServers = new CopyOnWriteArraySet&lt;WebSocketServer&gt;(); private Session session; /**客服端连接的时候触发 * @throws IOException */ @OnOpen public void onOpen(Session session) throws IOException{ this.session = session; webSocketServers.add(this); String message = &quot;{webSocketSessionId:&apos;&quot;+session.getId()+&quot;&apos;}&quot;; sendMessage(message); Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;type&quot;, &quot;1&quot;); map.put(&quot;content&quot;, session.getId()); sendMessageToAll(map); logger.info(&quot;sessionID：&quot;+session.getId()+&quot;,Open触发&quot;); } /**当客服端断开连接时触发 * @throws IOException */ @OnClose public void onClose() throws IOException{ webSocketServers.remove(this); Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;type&quot;, &quot;2&quot;); map.put(&quot;content&quot;, this.session.getId()); sendMessageToAll(map); logger.info(&quot;sessionID：&quot;+this.session.getId()+&quot;,Close触发&quot;); } /**接受客服端发来的信息 * * */ @OnMessage public void onMessage(String message, Session session) { } @OnError public void onError(Session session, Throwable error) { logger.info(&quot;sessionID：&quot;+session.getId()+&quot;,error触发&quot;); } //给当前客户端发送信息 public void sendMessage(String message) throws IOException { this.session.getBasicRemote().sendText(message); } //广播0 public void sendMessageToAll(Session session) throws IOException{ for(WebSocketServer wServer:webSocketServers){ wServer.session.getBasicRemote().sendText(&quot;{content:&apos;&quot;+session.getId()+&quot;&apos;}&quot;); } } //广播1 public void sendMessageToAll(String message) throws IOException{ for(WebSocketServer wServer:webSocketServers){ wServer.session.getBasicRemote().sendText(message); } } //广播2 public void sendMessageToAll(Map&lt;String, String&gt;map) throws IOException{ String message = &quot;&quot;; if(null != map&amp;&amp; map.size() != 0){ for(String key:map.keySet()){ message += key + &quot;:&quot; +&quot;&apos;&quot;+map.get(key)+&quot;&apos;,&quot;; } } message = message.substring(0,message.length()-1); for(WebSocketServer wServer:webSocketServers){ wServer.session.getBasicRemote().sendText(&quot;{&quot;+message+&quot;}&quot;); } } } 注意：使用websocket时产生的错误 依赖完全正确但是架包找不到，此时需要点击fix project setup添加tomcat8.5版本的架包 。 服务器主动发送消息&nbsp;&nbsp;&nbsp;&nbsp;服务器主动发送消息的核心理念就是操作session，通过session发送给指定的客户端。服务器主动发送消息可以发送给指定的用户也可以广播给所有用户，下面是核心代码： this.session.getBasicRemote().sendText(&quot;message&quot;); 客户端 //判断当前浏览器是否支持WebSocket if (&quot;WebSocket&quot; in window){ var websocket = new WebSocket(&quot;ws://localhost:8089/websocket&quot;); //连接发生错误的回调方法 websocket.onerror = function(){ layer.msg(&quot;the websocket server is error!&quot;); }; //连接成功建立的回调方法 websocket.onopen = function(event){ //向服务器主动发送消息 websocket.send(&quot;message&quot;); } //被动获取服务器端传送的数据 websocket.onmessage = function(event){ // 转换为json格式 var json = eval(&quot;(&quot;+event.data+&quot;)&quot;); } //连接关闭的回调方法 websocket.onclose = function(){ } //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function(){ websocket.close(); } //关闭连接 function closeWebSocket(){ websocket.close(); } } 注意：当页面加载了上述jq代码就已经与服务器建立了连接，离开页面就断开了连接。 三、总结 大部分人使用WebSocket就是看上了它能主动发送消息给客户端，因此知道如何主动发送消息很重要同时这也是最难理解的地方。上述代码中通过调用sendMessage(message);方法来进行主动发送消息，也可以获取到WebSocket的session来进行主动发送消息this.session.getBasicRemote().sendText(“message”);]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Quartz]]></title>
    <url>%2Fblog%2F2019%2F01%2F10%2FSpringBoot%E6%95%B4%E5%90%88Quartz%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 前言 知识概念 一、什么是Quartz？ Quartz是一个完全由java编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。二、Quartz架构Quartz架构有4个核心概念：Job 、JobDetail 、Trigger 、Scheduler • Job：表示一个工作或任务，包含具体执行的内容。• JobDetail：表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。• Trigger：表示触发器，包含可执行调度程序的时间参数配置，是可执行调度程序的时间执行策略• Scheduler：代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger，当JobDetail和Trigger组合，就可以被调度容器调度了三、示例框架：Springboot;&nbsp;&nbsp;(quartz官方Demo)Pom.xml &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;/dependency&gt; quartz.properties //Quartz //线程调度器实例名 org.quartz.scheduler.instanceName = quartzScheduler //如何存储任务和触发器等信息 org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX //驱动代理 org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate //表前缀 org.quartz.jobStore.tablePrefix = qrtz_ //数据源 must org.quartz.jobStore.dataSource = quartzDataSource //是否集群 org.quartz.jobStore.isClustered = false org.quartz.dataSource.quartzDataSource.connectionProvider.class=com.alibaba.druid.support.quartz.DruidQuartzConnectionProvider org.quartz.dataSource.quartzDataSource.driverClassName =com.mysql.jdbc.Driver org.quartz.dataSource.quartzDataSource.Url=jdbc:mysql://localhost:3306/quartz?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf8 org.quartz.dataSource.quartzDataSource.username=root org.quartz.dataSource.quartzDataSource.password=root org.quartz.dataSource.quartzDataSource.validationQuery=SELECT 1 FROM DUAL //线程池的线程数 must&gt;0 org.quartz.threadPool.threadCount = 3 1、Job public class BarrageJob implements Job{ private static Logger logger = Logger.getLogger(BarrageJob.class); @Autowired BarrageService barrageService; @Autowired QuartzService quartzService; //任务的具体执行内容 @Override public void execute(JobExecutionContext context) throws JobExecutionException { logger.info(&quot;BarrageJob开始执行&quot;); Date date = new Date(); Timestamp time = new Timestamp(date.getTime()); Integer count = barrageService.getBarrageCount(time); quartzService.insertJobData(new QrtzJobData(-1,context.getJobDetail().getKey().getName(),time,String.valueOf(count),BarrageJob.class.getName())); logger.info(&quot;BarrageJob执行完毕&quot;); } } 注意：BarrageJob中的注解正常情况下是无效的，因为它没有被Spring容器管理，因此需要在下面手动注入到容器中。 2、JobDetail JobDetail myjob = JobBuilder.newJob(BarrageJob.class).withIdentity(jobName, jobGroupName).build(); 3、Trigger Quartz提供了多个Trigger供我们选择(详情请查看相关源码)，可以选择其一例如：CronTrigger CronTrigger trigger = TriggerBuilder.newTrigger(). withSchedule(CronScheduleBuilder.cronSchedule(Cron表达式).withIdentity(triggerName, triggerGroup).startAt(开始时间).endAt(结束时间).build(); Cron表达式规则可以自行百度 4、Scheduler ScheduleConfig： @Configuration public class ScheduleConfig { //添加工作监听如不需要可注释 @Autowired MyJobListener myJobListener; //注册此工厂是为了使得在任务或工作即Job中也能使用Spring注解 @Autowired MyJobFactory myJobFactory; @Bean public SchedulerFactoryBean getSchedulerFactoryBean(){ SchedulerFactoryBean factory = new SchedulerFactoryBean(); factory.setJobFactory(myJobFactory); Properties quartzProperties = ReadResourceUtils.getProperties(&quot;quartz.properties&quot;); //可以选择不加载自定义的properties文件，系统会加载默认的配置文件 if(null != quartzProperties)factory.setQuartzProperties(quartzProperties); return factory; } @Bean(name=&quot;myScheduler&quot;) public Scheduler getScheduler() throws SchedulerException{ //SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = getSchedulerFactoryBean().getScheduler(); scheduler.getListenerManager().addJobListener(myJobListener); return scheduler; } } MyJobFactory： @Component public class MyJobFactory extends AdaptableJobFactory{ @Autowired private AutowireCapableBeanFactory factory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception { // 调用父类的方法 Object jobInstance = super.createJobInstance(bundle); // 进行注入 factory.autowireBean(jobInstance); return jobInstance; } } MyJobListener： @Component public class MyJobListener implements JobListener { @Override public String getName() { return &quot;myJobListener&quot;; } @Autowired QuartzService quartzService; @Override public void jobToBeExecuted(JobExecutionContext context) { System.out.println(&quot;start:jobToBeExecuted&quot;); String jobName = context.getJobDetail().getKey().getName(); System.out.println(&quot;end:jobToBeExecuted&quot;); } @Override public void jobExecutionVetoed(JobExecutionContext context) { } /**任务执行后更新任务状态*/ @Override public void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException) { System.out.println(&quot;start:jobWasExecuted&quot;); String jobName = context.getJobDetail().getKey().getName(); System.out.println(&quot;end:jobWasExecuted&quot;); } } 5、绑定JobDetail和CronTrigger到scheduler容器中 因为上面scheduler配置的时候已经将scheduler交给Spring容器进行管理了此时只需要自动注入 就可以获得scheduler容器 //将JobDetail和CronTrigger绑定到scheduler容器中 scheduler.scheduleJob(JobDetail, CronTrigger); //调度任务 scheduler.start(); 三、总结 使用Quartz首先要理解它的4大核心概念，接着理清楚它的流程就可以很快掌握]]></content>
      <categories>
        <category>SpringBoot整合</category>
      </categories>
      <tags>
        <tag>quartz</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合shiro详解]]></title>
    <url>%2Fblog%2F2019%2F01%2F09%2Fspringboot%E6%95%B4%E5%90%88shiro%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 前言 记得在我培训的时候为了防止用户在不登入的状态下访问到其他页面，需要是在jsp中写一个防盗链，始终感觉那样挺麻烦的而且功能还单一，然后就想到使用shiro。 知识概念 一、什么是shiro？ 简单来说shiro是一个开源安全的框架，它可以让我们更加简单方便的处理身份认证、授权、会话管理以及加密等功能。二、shiro能做什么？• Authentication：验证用户身份，有点类似防盗链• Authorization：给用户赋予权限，不同的用户可以拥有不同的权限，同时根据权限的不同可以限制其访问的范围• Session Management：管理用户会话，即使没有web容器或者EJB容器也可以管理• Cryptography：数据安全加密• Web Support：拥有一套健全的WebApi支持Web应用程序开发• Caching：shiro支持数据缓存，保证数据访问安全、高效、快速• Concurrency：shiro支持并发多线程应用程序• Testing：shiro支持测试应用程序• Run As：支持用户伪装成另一个用户身份，通常是管理员测试使用• Remember Me：在Session中记住用户身份，Session不失效，就不会要求你重新登入，当Session失效或被强制退出时需要重新登入 • SSO:shiro支持应用程序实现单点登入，即一个账户不能同时在多个地方登入三、shiro架构Shiro架构有3个主要概念：Subject、SecurityManager、Realm• Subject：相当于用户的意思，但是这里的用户泛指任何事物，不一定是人可以是第三方进程也可以是后台账户等泛指当前正在与软件进行交互的东西，每个Subject都需要与SecurityManager进行绑定，所有Subject统一交由SecurityManager进行管理，访问Subject其实就是访问SecurityManager中特定的subject。• SecurityManager：SecurityManager是shiro的核心，对Subject的安全操作进行保护，统一管理所有Subject。• Realms：Realm相当于一个特定的安全DAO，充当数据与应用程序交互的桥梁。Realms定义了认证、授权方式，如果默认的Realm不能满足你的需求，可以自定义Realm来满足需求。配置shiro时，至少需要一个Realm用来进行身份验证或授权，SecurityManager可以配置多个Realm，但至少一个是必须的。四、示例框架：Springboot;shiro官方DemoPoom.xml &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; 通过shiro架构图我们可以清楚的知道流程执行顺序，那么实现shiro的功能就需要逆推原理。1、自定义的Realm实现如下图shiro定义了很多类或抽象类供我们来实现自定义的Realm,我选用的是继承AuthorizingRealm,因此需要重写它的两个方法doGetAuthorizationInfo和doGetAuthenticationInfo方法。 UserRealm： public class UserRealm extends AuthorizingRealm{ @Autowired UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals) { String userName = (String)principals.fromRealm(getName()).iterator().next(); User user = userService.getUserInfoByUname(userName); if(null == user)return null; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); for(Role role:user.getRoleList()){ info.addRole(role.getRole()); for(Permission p:role.getPermissionList()){ info.addStringPermission(p.getPermission()); } } return info; } @Override protected AuthenticationInfo doGetAuthenticationInfo( AuthenticationToken token) throws AuthenticationException { String userName = (String) token.getPrincipal(); if(null != userName &amp;&amp; !userName.equals(&quot;&quot;)){ User user = userService.getUserByUname(userName); if(null != user ){ return new SimpleAuthenticationInfo(userName,user.getUserPwd(),getName()); } //如果用户都不存在那么一定验证失败 throw new AuthenticationException(); } throw new AuthenticationException(); } } 1、doGetAuthorizationInfo方法的作用看代码也知道是授权，这个就不多说了。2、doGetAuthenticationInfo方法的作用是身份认证但是并没有验证密码是否正确，真正验证身份的正确性是在AuthenticatingRealm的assertCredentialsMatch中体现，具体请看shiro官方给出的源码：继承关系:如下图 AuthenticatingRealm抽象类中的方法： public final AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { AuthenticationInfo info = getCachedAuthenticationInfo(token); if (info == null) { //otherwise not cached, perform the lookup: //此处会调用自定义中重写的doGetAuthenticationInfo方法 info = doGetAuthenticationInfo(token); log.debug(&quot;Looked up AuthenticationInfo [{}] from doGetAuthenticationInfo&quot;, info); if (token != null &amp;&amp; info != null) { cacheAuthenticationInfoIfPossible(token, info); } } else { log.debug(&quot;Using cached authentication info [{}] to perform credentials matching.&quot;, info); } if (info != null) { assertCredentialsMatch(token, info); } else { log.debug(&quot;No AuthenticationInfo found for submitted AuthenticationToken [{}]. Returning null.&quot;, token); } return info; } protected void assertCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) throws AuthenticationException { CredentialsMatcher cm = getCredentialsMatcher(); if (cm != null) { //此处是验证账号密码的正确性 if (!cm.doCredentialsMatch(token, info)) { //not successful - throw an exception to indicate this: String msg = &quot;Submitted credentials for token [&quot; + token + &quot;] did not match the expected credentials.&quot;; throw new IncorrectCredentialsException(msg); } } else { throw new AuthenticationException(&quot;A CredentialsMatcher must be configured in order to verify &quot; + &quot;credentials during authentication. If you do not wish for credentials to be examined, you &quot; + &quot;can configure an &quot; + AllowAllCredentialsMatcher.class.getName() + &quot; instance.&quot;); } } &nbsp;&nbsp;&nbsp;&nbsp;从上述源码中可以看出cm.doCredentialsMatch(token, info)才是验证的关键，token中有登入时的账号和密码，info是自定义UserRealm中的doGetAuthenticationInfo返回的对象也有账号和密码，当cm.doCredentialsMatch(token, info)为真的时候证明身份认证成功，当为假的时候登入不成功但是会抛出throw new IncorrectCredentialsException(msg)异常，此时只需要在Subject.login(token)上try，catch捕获AuthenticationException或IncorrectCredentialsException异常即可 2、SecurityManager配置 @Configuration public class ShiroConfiguration { //将自己的验证方式加入容器 @Bean public UserRealm myShiroRealm() { UserRealm myShiroRealm = new UserRealm(); return myShiroRealm; } //SecurityManager配置 @Bean public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); return securityManager; } //Filter工厂，设置对应的过滤条件和跳转条件 @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); Map&lt;String,String&gt; map = new ConcurrentHashMap&lt;String, String&gt;(); //登出 map.put(&quot;/logout&quot;,&quot;logout&quot;); //对所有用户认证 map.put(&quot;/**&quot;,&quot;authc&quot;); map.put(&quot;/user/validate&quot;,&quot;anon&quot;); //静态资源匿名获取，否则页面将无法获取样式等 map.put(&quot;/static/**&quot;, &quot;anon&quot;); map.put(&quot;/css/**&quot;, &quot;anon&quot;); map.put(&quot;/swf/**&quot;, &quot;anon&quot;); map.put(&quot;/fonts/**&quot;, &quot;anon&quot;); map.put(&quot;/img/**&quot;, &quot;anon&quot;); map.put(&quot;/js/**&quot;, &quot;anon&quot;); map.put(&quot;/layer/**&quot;, &quot;anon&quot;); map.put(&quot;/layer/theme/default/**&quot;,&quot;anon&quot;); map.put(&quot;/layer/mobile/**&quot;,&quot;anon&quot;); map.put(&quot;/i18n/**&quot;,&quot;anon&quot;); //url拦截，匿名提交会自动跳转到登录界面 shiroFilterFactoryBean.setLoginUrl(&quot;/&quot;); //登录成功首页 //shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;); //错误页面，认证不通过跳转 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(map); return shiroFilterFactoryBean; } //提供Aop支持 @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } //当用户没有权限的时候跳进指定的页面 @Bean public SimpleMappingExceptionResolver unauthoriedCatch(){ SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties exception = new Properties(); //value 是页面的名称不是controller中的路径 exception.setProperty(&quot;org.apache.shiro.authz.UnauthorizedException&quot;, &quot;unauthorized&quot;); exceptionResolver.setExceptionMappings(exception); return exceptionResolver; } } 3、获取当前正在与软件交互的Subject Subject subject = SecurityUtils.getSubject(); 获取后就可以进行很多操作，例如 UsernamePasswordToken token = new UsernamePasswordToken(username,password); 登入:subject.login(token); 登出:subject.logout(); 获取Session：subject.getSessioin()； 4、给请求增加权限或角色限制 @RequiresRoles(value={&quot;Admin&quot;,&quot;SuperAdmin&quot;},logical=Logical.OR) @RequiresPermissions(&quot;database&quot;) 用户登录成功时会根据你在自定义的UserRealm中doGetAuthorizationInfo方法给用户赋予相应角色和权限， 如果用户的权限或角色满足注解上权限或角色限制就可以成功访问否则就跳转到指定的页面 总结 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个流程:当用户登入时需要先获取当前正在与软件交互的Subject对象，然后调用login方法进行登录，登录会先验证身份如果验证成功就给用户赋予权限和角色，此时用户已经登入成功了，但是有些url是需要一定的权限或角色才能访问，所以在请求这些url的时候会根据该用户的权限或角色去跟url上的限制进行匹配如果成功就放行否则就会被阻挡]]></content>
      <categories>
        <category>springboot整合</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Shiro</tag>
        <tag>整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载的过程]]></title>
    <url>%2Fblog%2F2018%2F11%2F05%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 最近在牛客刷题，经常会遇到一些类、对象加载初始化的一些很细微的问题，似懂非懂。 知识概念 加载：简单来说就是通过类的全限定名称获取数据并在堆中创建一个对象作为数据访问入口验证：检验Class文件数据信息是否符合虚拟机的要求准备：此阶段是对类变量进行分配内存和初始化（注意：此处初始化是给系统默认值即零值(一般情况)，真正的赋值在上图中的初始化阶段。特殊情况:被final修饰的类变量如public static final int test = 1;此时就直接赋值为1了。）解析：对字段、方法、接口进行解析，这个交给虚拟机来完成，不必过多深究。初始化：真正开始执行java中的程序代码，例如：对类变量进行初始化，执行静态代码块等 注意：上图5个过程除了解析过程其他过程都是要按照图中顺序开始，（注意：这里的顺序不是一定要等前面一个过程完成后才开始下一个过程），解析过程可以在加载的时候也可以在初始化的时候，这个交给虚拟机来判断。初始化时机1、new实例化对象的时候（注：类未被加载过）。 2、引用静态变量3、引用静态方法4、使用反射5、初始化当前类的父类（如果存在）未被加载过6、主类（main方法）附加：实例对象加载过程从面两个过程图我们可以清楚的知道为什么成员变量和类变量可以不用赋初值(类变量会在准备阶段赋值零值，成员变量会在调用构造函数的时候初始化),而局部变量需要赋初值。]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>类加载</tag>
        <tag>过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特殊符号]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2F%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[前言 .前几天做公司项目的时候，遇到需要切割字符串，其中就有个特殊符号.使用split切割符号得到的结果全是null值，于是就想到需要进行转义。故记录一些需要转义的特殊符号。 特殊符号：( &nbsp;&nbsp;&nbsp; [ &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp;?&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp; . &nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp; - &nbsp;&nbsp;&nbsp; $ &nbsp;&nbsp;&nbsp; ¦ &nbsp;&nbsp;&nbsp; 使用方法：split(“//.”)]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>split</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ipv4和Ipv6校验]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2FIpv4%E5%92%8CIpv6%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 前言 公司项目需要验证ip地址 function isIPv6(ip)//IPV6地址判断 { return /:/.test(ip) &amp;&amp; str.match(/:/g).length&lt;8 &amp;&amp; /::/.test(ip) ?(str.match(/::/g).length==1 &amp;&amp; /^::$|^(::)?([\da-f]{1,4}(:|::))*[\da-f]{1,4}(:|::)?$/i.test(str)) :/^([\da-f]{1,4}:){7}[\da-f]{1,4}$/i.test(ip); s} function isIpv4(ip)//IPV4地址判断 { var exp=/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/; return ip.match(exp); }]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>Ipv4</tag>
        <tag>Ipv6</tag>
        <tag>validate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FontAwesome]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2FFontAwesome%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 前言 最近在做项目，然后会需要一些小图标。也尝试去百度然后下载或者p图，一两个还行多了就感觉非常麻烦，就非常苦恼，偶然间发现Font Awesome,感觉非常好用，现在记录一下使用方法。 资源库Font Awesome中文网 正文第一步下载资源包（上面是中文网，图标很多很齐全）。如下图将css和fonts放入项目中就ok。第二步在页面中引用 &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/font-awesome/css/font-awesome.min.css&quot;&gt; 第三步使用具体图标了，如下图点击你想要的小图标，如下图可以查看具体使用情况如下图， Tip:图标的样式通过css可以进行调整，比如想换颜色，就将font-color设置成想要的颜色即可。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>FontAwesome</tag>
        <tag>Small icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MybatisGenerator自动构建代码]]></title>
    <url>%2Fblog%2F2018%2F09%2F04%2FMybatisGenerator%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[详情请点击这里]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Generator</tag>
        <tag>自动构建代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对git仓库的理解]]></title>
    <url>%2Fblog%2F2018%2F08%2F23%2F%E5%AF%B9git%E4%BB%93%E5%BA%93%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 最近也是在使用git，经常会出现一些bug很是头疼。后来发现是前期知识不扎实，没有彻底的理解git仓库的结构，只是出现bug就百度，但是百度的有时候效也没有用，这就非常的苦恼了，所以就有了这篇文章。 知识概念 如上图这就是一个git仓库，不管你是通过git bash git init初始化还是通过eclipse clone一个远程仓库都会创建这样一个目录，现在来解释一下它们的含义。 目录：git管理的一个目录也就是一个git仓库。工作区：目录下，.git文件夹以外的都是工作区。工作区的目的是存放需要git进行版本控制的文件或者文件夹。版本库：目录下的.git的文件夹就是版本库。Stage：也称为index，指的是暂存区,目的是对文件进行标记。local Repo:指的是你的本地库，所谓的提交到远程仓库就是将你本地库上的东西提交上去 本地操作 了解了这些好像也没什么用，之前我也是这么觉得，哈哈，别急，通过下面实战完成一次commit操作你就会知道它们的作用了。 首先在git仓库中的工作区创建两个文件test.txt和test1.txt,然后使用git status命令查看工作区文件的状态如下图 我们可以看到两个文件显示的是红色而且是在Untracked files中（Untracked files表示未跟踪的文件），表明此时在工作区的两个文件都没有进行到版本控制。下面通过 git add test.txt将test.txt文件添加到暂存区中，此时文件颜色变成了绿色，表示已被追踪且已暂存。 注：1、未添加的文件不会进行版本控制。2、已经追踪的文件修改后也会变成红色，此时需要重新添加到暂存区 此时通过git commit -m “提交”命令将暂存区的文件提交到你的本地库中，以上所有操作都是在本地完成不牵扯远程仓库。 知识点：1、清除本次修改内容（在提交到暂存区之前）：git checkout – filename2、从暂存区中清除：git reset HEAD filename(如果此文件此前已经提交过到本地库，则此时该文件还是已追踪状态否则变成未追踪状态)3、取消已追踪文件的追踪：git rm –cached filename(配合commit命令会在本地库中清除该文件，工作区的文件不会删除)4、删除工作区文件:git rm filename(配合commit命令会同时删除本地库和工作区的文件) 远程仓库的操作 首先使用git remote -v查看远程仓库，然后创建一个与已有名称不同的远程仓库。git remote add ssh(https)，因为前面已经commit到本地库了，现在可以push推送到远程仓库了。使用命令：git push origin test:master意思是将本地库中test分支的东西提交到远程仓库origin的master分支上，也可以简写为 git push origin master,意思是将当前分支提交到远程仓库origin的master分支上，同样也可以简写为git push 但是这个要指定默认仓库即第一次提交的时候使用参数-u。 冲突解决 有时候会遇到远程仓库和你本地内容不同(不是包含关系)，此时push就会产生冲突，因此就需要解决冲突。 首先需要将你本地的最新内容提交到本地库中否则无法进行merge操作。提交完成后使用命令:git fetch origin master,将远程仓库origin的master分支的数据拉下来，然后在使用命令:git merge origin/master合并一下，这时候你就会在冲突文件中看到多了一些信息。其中HEAD到======上是指你修改的下面的======到origin/master是远程仓库的内容，远程仓库的内容的和你修改的不是同一个地方就将这些HEAD等信息数据删掉然后重新add commit push就解决了，如果修改的是同一个的地方就看谁的是正确的把错误的删掉，同样add commit push 就ok了 总结 1、首先要理解git的一些相关概念，如它的工作区域等2、注意看git bash的提示信息，它的提示信息可以帮助你解决很多问题。 通过使用命令行你可以更清楚的知道它运作的原理。如果你使用命令行都能操作git那么使用eclipse操作就更容易了。 Git教程：https://git-scm.com/book/zh/v2/起步-Git-基础]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>本地库</tag>
        <tag>暂存区</tag>
        <tag>工作区</tag>
        <tag>解决冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析ConcurrentModificationException异常的原因]]></title>
    <url>%2Fblog%2F2018%2F08%2F15%2F%E6%B5%85%E6%9E%90ConcurrentModificationException%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 在分析前我们先做几个测试 public class TestList { public static void main(String[]args){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;1&quot;);list.add(&quot;2&quot;); list.add(&quot;3&quot;);list.add(&quot;4&quot;); TestList.testFor(list); TestList.testForeach(list); TestList.testIteratorForListRemove(list); TestList.testIteratorForIteratorRemove(list); } //测试For循环 public static void testFor(List&lt;String&gt; list){ try{ for(int i=0;i&lt;list.size();i++){ System.out.println(&quot;长度：&quot;+list.size()); if(list.contains(&quot;1&quot;)){ list.remove(i); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } //测试Foreach循环 public static void testForeach(List&lt;String&gt; list){ try{ for(String str:list){ System.out.println(&quot;长度：&quot;+list.size()); if(list.contains(&quot;1&quot;)){ list.remove(str); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } //测试迭代器使用List的remove方法 public static void testIteratorForListRemove(List&lt;String&gt; list){ try{ Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ System.out.println(&quot;长度：&quot;+list.size()); String str = it.next(); if(list.contains(&quot;1&quot;)){ list.remove(str); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } //测试迭代器使用迭代器的remove方法 public static void testIteratorForIteratorRemove(List&lt;String&gt; list){ try{ Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ System.out.println(&quot;长度：&quot;+list.size()); String str = it.next(); if(list.contains(&quot;1&quot;)){ it.remove(); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } } 结果展示 //For循环 长度：4 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- //Foreach循环（捕获异常） 长度：4 长度：3 ----------------------------- 出现ConcurrentModificationException异常 //迭代器List的remove（捕获异常） 长度：4 长度：3 ----------------------------- 长度：3 出现ConcurrentModificationException异常 //迭代器的remove 长度：4 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 通过结果显示我们能很清楚的知道使用Foreach和使用迭代器且使用List自身的remove方法会抛出ConcurrentModificationException异常。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么为什么会是这样的结果呢？首先先分析这四个遍历的情况，第一个For循环是最基础的循环，其他三个都是使用了迭代器进行循环，而抛出的异常的都是使用了迭代器的循环，由此我们可以推断产生异常的原因和迭代器内部机制有很大的关系，这就好办了，现在我们来看看Iterator迭代器中的源码情况，在这里注意一下expectedModCount、modCount这两个变量，抛出异常就是它们两个不相等，下面详细讲解为什么会不相等。 //源码 private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 通过上面的测试示例我们可以很清楚的知道会用到源码中的hashNext、next、remove等方法，先分析Foreach循环，Foreach循环的原理是默认会调用迭代器中的hashNext和next方法，首先先用hashNext方法判断是否还有下一个元素，如果有，就调用next方法，获取这个元素并赋值给冒号前面的变量，如此重复直至hashNext为fasle的时候就会结束循环。因此Foreach循环会调用迭代器中的两个方法hashNext和next，hashNext方法我们看源码没有什么毛病，重点是在next方法。 public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 首先看第一行它会调用checkForComodification方法进行检查modCount和expectedModCount是否相等，不相等就会抛出异常。这时候你会有疑问了（在源码中它们是相等的啊）？ int expectedModCount = modCount; 没错在迭代器中它们是相等的，但是你调用了list.remove(index)方法，注意看下面代码remove方法的第二行，modCount++;自增了，当list调用了remove方法后Foreach循环会调用迭代器中的next方法，next方法会调用checkForComodification方法进行判断所以就会抛出ConcurrentModificationException异常。 //ArrayList中的remove方法 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 那么为什么第四个方法也就是使用了迭代器本身的remove方法不会报错呢？且看源码 public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 迭代器中的已经对这两个变量做了处理让它们始终是相等的。总结&nbsp;&nbsp;1、尽量不要在遍历的时候修改集合中的元素&nbsp;&nbsp;2、如果硬要修改就使用迭代器本身自带的修改元素的方法&nbsp;&nbsp;&nbsp;&nbsp;3、哈哈，选择for循环是最稳的]]></content>
      <categories>
        <category>java基础知识</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>迭代器</tag>
        <tag>ConcurrentModificationException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github快速高效搭建一个自定义页面作为首页的博客]]></title>
    <url>%2Fblog%2F2018%2F08%2F14%2Fhexo-github%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E4%BD%9C%E4%B8%BA%E9%A6%96%E9%A1%B5%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hljs.initHighlightingOnLoad(); 前言 &nbsp;&nbsp;&nbsp;&nbsp;先从标题来说，为什么说是快速高效呢？因为我已经把大部分坑都踩过了，是不是很贴心，哈哈，在会出现错误的地方我会给予相应的提示和出错解决方法，这样可以减少不必要的解决bug的时间，废话少说，下面开始吧。 准备工作 1、构建git环境&nbsp;&nbsp;&nbsp;&nbsp;构建git环境是指本地安装git软件以及与远程github相连，如果这一步已经完成了的可以进入下一步，如果未完成的请点击这里2、安装node.js&nbsp;&nbsp;&nbsp;&nbsp;安装Node.js(傻瓜式安装一键到底)3、搭建hexo环境 （官方教程请点击这里 ） 1、使用第一步安装好的Git Bash工具，输入：npm install -g hexo-cli 安装hexo，如图注：如果产生错误提示：npm command not found则说明一种可能是你第二步安装Node.js的配置未生效，可以先到本地电脑属性 &rarr; 高级系统设置&rarr;环境变量&rarr;path中查看是否有Node.js软件的安装路径（eg: C:\Program Files\nodejs），如果忘记安装的位置就重启一下电脑系统自动会配置。&nbsp;&nbsp;2、hexo init 地址，初始化一个工作空间，地址随便填写也可以不写，不写就是在当前目录下创建（建议创建一个目录），尽量短些，因为后续很多操作是需要在这个工作空间执行的，避免切换目录输入的麻烦。&nbsp;&nbsp;3、输入命令 cd 地址，切换到刚才你初始化的工作空间&nbsp;&nbsp;4、安装npm，输入命令 ： npm install&nbsp;&nbsp;注：常见错误：1、部署的时候提示找不到git解决方法：npm install hexo-deployer-git –save2、执行hexo server提示找不到该指令解决方法：npm install hexo-server –save 快速开始&emsp;&emsp;首先先理清楚自己的需求，我们需要的是做一个具有自定义页面作为首页的博客，因此需要在github中创建两个仓库，一个仓库是放自定义页面，另一个是放博客主页的。&emsp;&emsp;先别着急一个一个来，首先先创建一个放自定义页面的仓库。1、进入github中点击New repository，名字为：xx.github.io,其中xx要与Owner一致。2、点击Settings并在GitHub Pages中点击Choose a theme，进入后随便选择一个主题，没关系因为之后都是要被替换成你自己的自定义页面。&emsp;&emsp;完成以上操作的时候，你的仓库中就会是这样的效果。&emsp;&emsp;之后就需要你自己设计一个页面然后将仓库的文件替换，我的仓库的效果图如下。 注：git操作：先进入你初始化的git工作空间，（如果忘记了在哪里了，可以重新初始化一个，输入命令：git init 地址）使用命令可以查看一下工作空间存在的文件信息： ls -a 输入命令可以查看当前有哪些远程库以及与那个github仓库连接： git remote -v 创建一个远程库以及与github仓库连接： git remote add origin ssh（origin是指起的远程仓库名称可以随便起，ssh指的是你仓库的地址详情如下图） 完成后可以将你需要上传的文件添加到暂存区中： git add xx 添加完成后使用命令： git status //查看是否添加成功，绿色标识已经添加到暂存区了 使用命令： git commit -m &quot;第一次提交&quot; //提交到本地库中 最后在使用: git push origin master //推送到github远程仓库中 &emsp;&emsp;如果以上步骤都成功了，那么现在可以开始创建第二个仓库也就是作为博客主体使用的，同样在github中新建一个仓库，这里的仓库名称是可以随便取，例如我取的名称是：blog,然后选一个主题，现在在github上的操作就已经完成了，那么现在回到本地进入hexo工作环境中，如下图，打开_congfig.yml文件，搜索关键字：url，对url和root进行配置（千万注意yml文件的格式很规范，不准使用tab键，冒号后面空1格，缩进是空2格，千万记住,设置错误找都找不到出错在哪里），例如： url: https://主页的名称/主体博客的名称 root: /主体博客的名称/ 此时已经完成前半部分配置，接下来搜索：deploy关键字，将hexo部署到哪里去，例如： deploy: type: git //部署方式 repository: https://github.com/ForeverLTP/log.git //repository是指你主体博客仓库的地址 branch: master //提交到master分支上 以上配置完成，现在可以将hexo部署到github中，使用命令： hexo c //等待完成后 hexo g //等待完成 hexo d 这样基础的具有自定义页面的基础博客就完成了。 总结1、注意yml文件的格式2、后续主体优化（网上很多教程）的时候相对路径记住是要多加一个路径，因为我们是有个自定义主页的，路径其实就是博客主体仓库的名称3、对git工作区、暂存区、本地库、远程仓库稍微理解一下，否则会遇到很多git上的错误。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>自定义</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源起]]></title>
    <url>%2Fblog%2F2018%2F08%2F13%2F%E6%BA%90%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;算算已经工作了半年了，经常会有一些问题需要去思考，有时候我知道它的意思，但是就是表达不出来，总感觉缺少些什么，这种朦胧懵懂的感觉很不好（这也是我不太会说的一个原因），所以我就想记录，在记录或者说整合的时候你会遇到其他各种各样的问题，这或许就是我缺少的那部分东西，所以我想要去探寻我那部分缺失的东西。&emsp;&emsp;哈哈，想拥有一个自己的博客很久，但是老是觉得自己技术不太行、没什么可写的而放弃。现在想开了，作为一个年轻人就是要敢于做，至少不会后悔，就像我首页说的那样JUST DO IT,做就完事了。&emsp;&emsp;搭建这个博客和首页样式的制作花费了我二天的时间，虽然网上有教程，但是当你自己去做的时候你会发现其实并不想教程中说的那么简单，即使完全按照他们的步骤来，因为种种原因，也会出错，也会有问题，这时候就要你自己来解决或百度解决，也许当时你会烦恼，但是当你都解决了的时候你会很高兴，那种无法形容的高兴，这就是问题它的魅力所在，同样也是我想要的感觉。&emsp;&emsp;说了这么多废话，总而言之，今天我的博客诞生了。最后，借我老师的一句话结尾，坐在台下你永远无法体会站在台上的压力。]]></content>
  </entry>
</search>
