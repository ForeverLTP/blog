<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[特殊符号]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2F%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[前言 .前几天做公司项目的时候，遇到需要切割字符串，其中就有个特殊符号.使用split切割符号得到的结果全是null值，于是就想到需要进行转义。故记录一些需要转义的特殊符号。 特殊符号：( &nbsp;&nbsp;&nbsp; [ &nbsp;&nbsp;&nbsp; { &nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp;?&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp; . &nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp; - &nbsp;&nbsp;&nbsp; $ &nbsp;&nbsp;&nbsp; ¦ &nbsp;&nbsp;&nbsp; 使用方法：split(“//.”)]]></content>
      <tags>
        <tag>split</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ipv4和Ipv6校验]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2FIpv4%E5%92%8CIpv6%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言 公司项目需要验证ip地址 function isIPv6(ip)//IPV6地址判断 { return /:/.test(ip) &amp;&amp; str.match(/:/g).length&lt;8 &amp;&amp; /::/.test(ip) ?(str.match(/::/g).length==1 &amp;&amp; /^::$|^(::)?([\da-f]{1,4}(:|::))*[\da-f]{1,4}(:|::)?$/i.test(str)) :/^([\da-f]{1,4}:){7}[\da-f]{1,4}$/i.test(ip); s} function isIpv4(ip)//IPV4地址判断 { var exp=/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/; return ip.match(exp); }]]></content>
      <tags>
        <tag>Ipv4</tag>
        <tag>Ipv6</tag>
        <tag>validate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FontAwesome]]></title>
    <url>%2Fblog%2F2018%2F10%2F07%2FFontAwesome%2F</url>
    <content type="text"><![CDATA[前言 最近在做项目，然后会需要一些小图标。也尝试去百度然后下载或者p图，一两个还行多了就感觉非常麻烦，就非常苦恼，偶然间发现Font Awesome,感觉非常好用，现在记录一下使用方法。 资源库Font Awesome中文网 正文第一步下载资源包（上面是中文网，图标很多很齐全）。如下图将css和fonts放入项目中就ok。第二步在页面中引用 &lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/font-awesome/css/font-awesome.min.css&quot;&gt; 第三步使用具体图标了，如下图点击你想要的小图标，如下图可以查看具体使用情况如下图， Tip:图标的样式通过css可以进行调整，比如想换颜色，就将font-color设置成想要的颜色即可。]]></content>
      <tags>
        <tag>FontAwesome</tag>
        <tag>Small icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MybatisGenerator自动构建代码]]></title>
    <url>%2Fblog%2F2018%2F09%2F04%2FMybatisGenerator%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[详情请点击这里]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Generator</tag>
        <tag>自动构建代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对git仓库的理解]]></title>
    <url>%2Fblog%2F2018%2F08%2F23%2F%E5%AF%B9git%E4%BB%93%E5%BA%93%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 最近也是在使用git，经常会出现一些bug很是头疼。后来发现是前期知识不扎实，没有彻底的理解git仓库的结构，只是出现bug就百度，但是百度的有时候效也没有用，这就非常的苦恼了，所以就有了这篇文章。 知识概念 如上图这就是一个git仓库，不管你是通过git bash git init初始化还是通过eclipse clone一个远程仓库都会创建这样一个目录，现在来解释一下它们的含义。 目录：git管理的一个目录也就是一个git仓库。工作区：目录下，.git文件夹以外的都是工作区。工作区的目的是存放需要git进行版本控制的文件或者文件夹。版本库：目录下的.git的文件夹就是版本库。Stage：也称为index，指的是暂存区,目的是对文件进行标记。local Repo:指的是你的本地库，所谓的提交到远程仓库就是将你本地库上的东西提交上去 本地操作 了解了这些好像也没什么用，之前我也是这么觉得，哈哈，别急，通过下面实战完成一次commit操作你就会知道它们的作用了。 首先在git仓库中的工作区创建两个文件test.txt和test1.txt,然后使用git status命令查看工作区文件的状态如下图 我们可以看到两个文件显示的是红色而且是在Untracked files中（Untracked files表示未跟踪的文件），表明此时在工作区的两个文件都没有进行到版本控制。下面通过 git add test.txt将test.txt文件添加到暂存区中，此时文件颜色变成了绿色，表示已被追踪且已暂存。 注：1、未添加的文件不会进行版本控制。2、已经追踪的文件修改后也会变成红色，此时需要重新添加到暂存区 此时通过git commit -m “提交”命令将暂存区的文件提交到你的本地库中，以上所有操作都是在本地完成不牵扯远程仓库。 知识点：1、清除本次修改内容（在提交到暂存区之前）：git checkout – filename2、从暂存区中清除：git reset HEAD filename(如果此文件此前已经提交过到本地库，则此时该文件还是已追踪状态否则变成未追踪状态)3、取消已追踪文件的追踪：git rm –cached filename(配合commit命令会在本地库中清除该文件，工作区的文件不会删除)4、删除工作区文件:git rm filename(配合commit命令会同时删除本地库和工作区的文件) 远程仓库的操作 首先使用git remote -v查看远程仓库，然后创建一个与已有名称不同的远程仓库。git remote add ssh(https)，因为前面已经commit到本地库了，现在可以push推送到远程仓库了。使用命令：git push origin test:master意思是将本地库中test分支的东西提交到远程仓库origin的master分支上，也可以简写为 git push origin master,意思是将当前分支提交到远程仓库origin的master分支上，同样也可以简写为git push 但是这个要指定默认仓库即第一次提交的时候使用参数-u。 冲突解决 有时候会遇到远程仓库和你本地内容不同(不是包含关系)，此时push就会产生冲突，因此就需要解决冲突。 首先需要将你本地的最新内容提交到本地库中否则无法进行merge操作。提交完成后使用命令:git fetch origin master,将远程仓库origin的master分支的数据拉下来，然后在使用命令:git merge origin/master合并一下，这时候你就会在冲突文件中看到多了一些信息。其中HEAD到======上是指你修改的下面的======到origin/master是远程仓库的内容，远程仓库的内容的和你修改的不是同一个地方就将这些HEAD等信息数据删掉然后重新add commit push就解决了，如果修改的是同一个的地方就看谁的是正确的把错误的删掉，同样add commit push 就ok了 总结 1、首先要理解git的一些相关概念，如它的工作区域等2、注意看git bash的提示信息，它的提示信息可以帮助你解决很多问题。 通过使用命令行你可以更清楚的知道它运作的原理。如果你使用命令行都能操作git那么使用eclipse操作就更容易了。 Git教程：https://git-scm.com/book/zh/v2/起步-Git-基础]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>本地库</tag>
        <tag>暂存区</tag>
        <tag>工作区</tag>
        <tag>解决冲突</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析ConcurrentModificationException异常的原因]]></title>
    <url>%2Fblog%2F2018%2F08%2F15%2F%E6%B5%85%E6%9E%90ConcurrentModificationException%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[在分析前我们先做几个测试 public class TestList { public static void main(String[]args){ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;1&quot;);list.add(&quot;2&quot;); list.add(&quot;3&quot;);list.add(&quot;4&quot;); TestList.testFor(list); TestList.testForeach(list); TestList.testIteratorForListRemove(list); TestList.testIteratorForIteratorRemove(list); } //测试For循环 public static void testFor(List&lt;String&gt; list){ try{ for(int i=0;i&lt;list.size();i++){ System.out.println(&quot;长度：&quot;+list.size()); if(list.contains(&quot;1&quot;)){ list.remove(i); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } //测试Foreach循环 public static void testForeach(List&lt;String&gt; list){ try{ for(String str:list){ System.out.println(&quot;长度：&quot;+list.size()); if(list.contains(&quot;1&quot;)){ list.remove(str); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } //测试迭代器使用List的remove方法 public static void testIteratorForListRemove(List&lt;String&gt; list){ try{ Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ System.out.println(&quot;长度：&quot;+list.size()); String str = it.next(); if(list.contains(&quot;1&quot;)){ list.remove(str); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } //测试迭代器使用迭代器的remove方法 public static void testIteratorForIteratorRemove(List&lt;String&gt; list){ try{ Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ System.out.println(&quot;长度：&quot;+list.size()); String str = it.next(); if(list.contains(&quot;1&quot;)){ it.remove(); } System.out.println(&quot;长度：&quot;+list.size()); System.out.println(&quot;-----------------------------&quot;); } }catch(ConcurrentModificationException e){ System.out.println(&quot;出现ConcurrentModificationException异常&quot;); } } } 结果展示 //For循环 长度：4 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- //Foreach循环（捕获异常） 长度：4 长度：3 ----------------------------- 出现ConcurrentModificationException异常 //迭代器List的remove（捕获异常） 长度：4 长度：3 ----------------------------- 长度：3 出现ConcurrentModificationException异常 //迭代器的remove 长度：4 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 长度：3 长度：3 ----------------------------- 通过结果显示我们能很清楚的知道使用Foreach和使用迭代器且使用List自身的remove方法会抛出ConcurrentModificationException异常。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么为什么会是这样的结果呢？首先先分析这四个遍历的情况，第一个For循环是最基础的循环，其他三个都是使用了迭代器进行循环，而抛出的异常的都是使用了迭代器的循环，由此我们可以推断产生异常的原因和迭代器内部机制有很大的关系，这就好办了，现在我们来看看Iterator迭代器中的源码情况，在这里注意一下expectedModCount、modCount这两个变量，抛出异常就是它们两个不相等，下面详细讲解为什么会不相等。 //源码 private class Itr implements Iterator&lt;E&gt; { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) { Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) { return; } final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) { throw new ConcurrentModificationException(); } while (i != size &amp;&amp; modCount == expectedModCount) { consumer.accept((E) elementData[i++]); } // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 通过上面的测试示例我们可以很清楚的知道会用到源码中的hashNext、next、remove等方法，先分析Foreach循环，Foreach循环的原理是默认会调用迭代器中的hashNext和next方法，首先先用hashNext方法判断是否还有下一个元素，如果有，就调用next方法，获取这个元素并赋值给冒号前面的变量，如此重复直至hashNext为fasle的时候就会结束循环。因此Foreach循环会调用迭代器中的两个方法hashNext和next，hashNext方法我们看源码没有什么毛病，重点是在next方法。 public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 首先看第一行它会调用checkForComodification方法进行检查modCount和expectedModCount是否相等，不相等就会抛出异常。这时候你会有疑问了（在源码中它们是相等的啊）？ int expectedModCount = modCount; 没错在迭代器中它们是相等的，但是你调用了list.remove(index)方法，注意看下面代码remove方法的第二行，modCount++;自增了，当list调用了remove方法后Foreach循环会调用迭代器中的next方法，next方法会调用checkForComodification方法进行判断所以就会抛出ConcurrentModificationException异常。 //ArrayList中的remove方法 public E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 那么为什么第四个方法也就是使用了迭代器本身的remove方法不会报错呢？且看源码 public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); } } 迭代器中的已经对这两个变量做了处理让它们始终是相等的。总结&nbsp;&nbsp;1、尽量不要在遍历的时候修改集合中的元素&nbsp;&nbsp;2、如果硬要修改就使用迭代器本身自带的修改元素的方法&nbsp;&nbsp;&nbsp;&nbsp;3、哈哈，选择for循环是最稳的]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>迭代器</tag>
        <tag>ConcurrentModificationException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github快速高效搭建一个自定义页面作为首页的博客]]></title>
    <url>%2Fblog%2F2018%2F08%2F14%2Fhexo-github%E5%BF%AB%E9%80%9F%E9%AB%98%E6%95%88%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E4%BD%9C%E4%B8%BA%E9%A6%96%E9%A1%B5%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;先从标题来说，为什么说是快速高效呢？因为我已经把大部分坑都踩过了，是不是很贴心，哈哈，在会出现错误的地方我会给予相应的提示和出错解决方法，这样可以减少不必要的解决bug的时间，废话少说，下面开始吧。 准备工作 1、构建git环境&nbsp;&nbsp;&nbsp;&nbsp;构建git环境是指本地安装git软件以及与远程github相连，如果这一步已经完成了的可以进入下一步，如果未完成的请点击这里2、安装node.js&nbsp;&nbsp;&nbsp;&nbsp;安装Node.js(傻瓜式安装一键到底)3、搭建hexo环境 （官方教程请点击这里 ） 1、使用第一步安装好的Git Bash工具，输入：npm install -g hexo-cli 安装hexo，如图注：如果产生错误提示：npm command not found则说明一种可能是你第二步安装Node.js的配置未生效，可以先到本地电脑属性 &rarr; 高级系统设置&rarr;环境变量&rarr;path中查看是否有Node.js软件的安装路径（eg: C:\Program Files\nodejs），如果忘记安装的位置就重启一下电脑系统自动会配置。&nbsp;&nbsp;2、hexo init 地址，初始化一个工作空间，地址随便填写也可以不写，不写就是在当前目录下创建（建议创建一个目录），尽量短些，因为后续很多操作是需要在这个工作空间执行的，避免切换目录输入的麻烦。&nbsp;&nbsp;3、输入命令 cd 地址，切换到刚才你初始化的工作空间&nbsp;&nbsp;4、安装npm，输入命令 ： npm install&nbsp;&nbsp;注：常见错误：1、部署的时候提示找不到git解决方法：npm install hexo-deployer-git –save2、执行hexo server提示找不到该指令解决方法：npm install hexo-server –save 快速开始&emsp;&emsp;首先先理清楚自己的需求，我们需要的是做一个具有自定义页面作为首页的博客，因此需要在github中创建两个仓库，一个仓库是放自定义页面，另一个是放博客主页的。&emsp;&emsp;先别着急一个一个来，首先先创建一个放自定义页面的仓库。1、进入github中点击New repository，名字为：xx.github.io,其中xx要与Owner一致。2、点击Settings并在GitHub Pages中点击Choose a theme，进入后随便选择一个主题，没关系因为之后都是要被替换成你自己的自定义页面。&emsp;&emsp;完成以上操作的时候，你的仓库中就会是这样的效果。&emsp;&emsp;之后就需要你自己设计一个页面然后将仓库的文件替换，我的仓库的效果图如下。 注：git操作：先进入你初始化的git工作空间，（如果忘记了在哪里了，可以重新初始化一个，输入命令：git init 地址）使用命令可以查看一下工作空间存在的文件信息： ls -a 输入命令可以查看当前有哪些远程库以及与那个github仓库连接： git remote -v 创建一个远程库以及与github仓库连接： git remote add origin ssh（origin是指起的远程仓库名称可以随便起，ssh指的是你仓库的地址详情如下图） 完成后可以将你需要上传的文件添加到暂存区中： git add xx 添加完成后使用命令： git status //查看是否添加成功，绿色标识已经添加到暂存区了 使用命令： git commit -m &quot;第一次提交&quot; //提交到本地库中 最后在使用: git push origin master //推送到github远程仓库中 &emsp;&emsp;如果以上步骤都成功了，那么现在可以开始创建第二个仓库也就是作为博客主体使用的，同样在github中新建一个仓库，这里的仓库名称是可以随便取，例如我取的名称是：blog,然后选一个主题，现在在github上的操作就已经完成了，那么现在回到本地进入hexo工作环境中，如下图，打开_congfig.yml文件，搜索关键字：url，对url和root进行配置（千万注意yml文件的格式很规范，不准使用tab键，冒号后面空1格，缩进是空2格，千万记住,设置错误找都找不到出错在哪里），例如： url: https://主页的名称/主体博客的名称 root: /主体博客的名称/ 此时已经完成前半部分配置，接下来搜索：deploy关键字，将hexo部署到哪里去，例如： deploy: type: git //部署方式 repository: https://github.com/ForeverLTP/log.git //repository是指你主体博客仓库的地址 branch: master //提交到master分支上 以上配置完成，现在可以将hexo部署到github中，使用命令： hexo c //等待完成后 hexo g //等待完成 hexo d 这样基础的具有自定义页面的基础博客就完成了。 总结1、注意yml文件的格式2、后续主体优化（网上很多教程）的时候相对路径记住是要多加一个路径，因为我们是有个自定义主页的，路径其实就是博客主体仓库的名称3、对git工作区、暂存区、本地库、远程仓库稍微理解一下，否则会遇到很多git上的错误。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>自定义</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[源起]]></title>
    <url>%2Fblog%2F2018%2F08%2F13%2F%E6%BA%90%E8%B5%B7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;算算已经工作了半年了，经常会有一些问题需要去思考，有时候我知道它的意思，但是就是表达不出来，总感觉缺少些什么，这种朦胧懵懂的感觉很不好（这也是我不太会说的一个原因），所以我就想记录，在记录或者说整合的时候你会遇到其他各种各样的问题，这或许就是我缺少的那部分东西，所以我想要去探寻我那部分缺失的东西。&emsp;&emsp;哈哈，想拥有一个自己的博客很久，但是老是觉得自己技术不太行、没什么可写的而放弃。现在想开了，作为一个年轻人就是要敢于做，至少不会后悔，就像我首页说的那样JUST DO IT,做就完事了。&emsp;&emsp;搭建这个博客和首页样式的制作花费了我二天的时间，虽然网上有教程，但是当你自己去做的时候你会发现其实并不想教程中说的那么简单，即使完全按照他们的步骤来，因为种种原因，也会出错，也会有问题，这时候就要你自己来解决或百度解决，也许当时你会烦恼，但是当你都解决了的时候你会很高兴，那种无法形容的高兴，这就是问题它的魅力所在，同样也是我想要的感觉。&emsp;&emsp;说了这么多废话，总而言之，今天我的博客诞生了。最后，借我老师的一句话结尾，坐在台下你永远无法体会站在台上的压力。]]></content>
  </entry>
</search>
